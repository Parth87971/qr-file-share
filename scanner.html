<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>QR File Receiver</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-slate-50 text-slate-800 antialiased">
    <div id="app" class="min-h-screen flex items-center justify-center p-4">
      <main class="w-full max-w-3xl bg-white rounded-2xl shadow-lg p-6">
        <header class="flex items-center justify-between mb-4">
          <h1 class="text-2xl font-semibold">QR File Receiver</h1>
          <div class="text-sm text-slate-500">Point your camera at the sender's QR code</div>
        </header>

        <section class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <div class="border rounded-lg overflow-hidden bg-black">
              <video id="videoElement" autoplay playsinline muted class="w-full h-64 object-cover bg-black"></video>
            </div>

            <div class="mt-3 flex gap-2">
              <button @click="startReceiver" :disabled="isReceiving" class="px-3 py-2 rounded bg-indigo-600 text-white">Start</button>
              <button @click="stopReceiver" :disabled="!isReceiving" class="px-3 py-2 rounded bg-rose-600 text-white">Stop</button>
              <select v-model="cameraId" @change="switchCamera" class="px-3 py-2 rounded border">
                <option value="">Select camera</option>
                <option v-for="c in cameras" :value="c.deviceId">{{ c.label || 'Camera ' + (cameras.indexOf(c)+1) }}</option>
              </select>
            </div>

            <div class="mt-3 text-sm text-slate-600">{{ statusMessage }}</div>

            <div class="mt-3">
              <div class="text-xs text-slate-500">Progress</div>
              <div class="w-full bg-slate-100 rounded overflow-hidden mt-1"><div :style="{ width: progressPct + '%' }" class="h-2 bg-indigo-500"></div></div>
              <div class="text-xs text-slate-500 mt-1">{{ receivedCount }} / {{ expectedChunks || 0 }}</div>
            </div>

          </div>

          <div>
            <div class="rounded-lg p-3 bg-slate-50">
              <div class="text-sm font-medium mb-1">File ready to download</div>
              <div v-if="completed" class="space-y-2">
                <div class="font-medium">{{ fileName }}</div>
                <div class="text-xs text-slate-500">Size: ~{{ formattedBytes(lastInflatedLength) }}</div>
                <a :href="downloadUrl" :download="fileName" class="inline-block px-3 py-2 bg-emerald-600 text-white rounded">Download file</a>
              </div>
              <div v-else class="text-xs text-slate-500">No completed file yet</div>

              <details class="mt-4 text-xs text-slate-400">
                <summary class="cursor-pointer">Debug</summary>
                <pre class="mt-2 max-h-52 overflow-auto text-xs bg-white p-2 rounded">{{ debug.join('\n') }}</pre>
              </details>
            </div>

            <div class="mt-4 text-xs text-slate-500">If scanning fails, try increasing chunk size on the sender, improve lighting, or hold camera steady. Works best with a separate device for sender and receiver.</div>
          </div>
        </section>

        <footer class="mt-6 text-xs text-slate-500">Static files â€” open `scanner.html` on the receiving device and allow camera permission.</footer>
      </main>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@undecaf/zbar-wasm@latest/dist/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.3/pako.min.js"></script>

    <script>
      const { createApp, ref, reactive, onMounted } = Vue;

      createApp({
        setup(){
          const isReceiving = ref(false);
          const statusMessage = ref('Idle');
          const cameras = ref([]);
          const cameraId = ref('');

          const expectedChunks = ref(0);
          const decodedChunks = reactive({});
          const receivedCount = ref(0);
          const progressPct = ref(0);

          const fileName = ref('');
          const downloadUrl = ref('');
          const completed = ref(false);
          const lastInflatedLength = ref(0);

          const debug = ref([]);

          let videoElement = null;
          let canvas = null;
          let ctx = null;
          let scanLoopActive = false;

          function log(s){ debug.value.unshift(new Date().toLocaleTimeString() + ' - ' + s); if(debug.value.length>200) debug.value.pop(); }

          async function listCameras(){
            try{
              const devices = await navigator.mediaDevices.enumerateDevices();
              cameras.value = devices.filter(d=>d.kind==='videoinput');
            }catch(e){ log('Could not list cameras: '+e); }
          }

          async function startReceiver(){
            isReceiving.value = true;
            statusMessage.value = 'Starting camera...';
            completed.value = false;
            // reset reactive object
            for (const k in decodedChunks) delete decodedChunks[k];
            receivedCount.value = 0;
            progressPct.value = 0;
            expectedChunks.value = 0;

            try{
              const constraints = cameraId.value ? { video: { deviceId: { exact: cameraId.value } } } : { video: { facingMode: 'environment' } };
              const stream = await navigator.mediaDevices.getUserMedia(constraints);
              videoElement.srcObject = stream;

              // configure canvas size after video plays
              await new Promise(r => setTimeout(r, 700));
              canvas.width = videoElement.videoWidth || 640;
              canvas.height = videoElement.videoHeight || 480;

              statusMessage.value = 'Scanning...';
              scanLoopActive = true;
              scanLoop();
            }catch(e){ statusMessage.value = 'Camera error: ' + e; log(e); isReceiving.value = false; }
          }

          function stopReceiver(){
            scanLoopActive = false;
            isReceiving.value = false;
            statusMessage.value = 'Stopped';
            try{ const tracks = videoElement.srcObject?.getTracks() || []; tracks.forEach(t=>t.stop()); videoElement.srcObject = null; }catch(e){ }
          }

          function decodePayload(decodedStr){
            if (!decodedStr) return;
            try{
              if (decodedStr.includes('chunks')){
                const meta = JSON.parse(decodedStr);
                expectedChunks.value = meta.chunks;
                fileName.value = meta.name;
                receivedCount.value = 0;
                progressPct.value = 0;
                log('Received metadata: ' + JSON.stringify(meta));
                return;
              }

              if (decodedStr.split(',').length === 2){
                const idx = parseInt(decodedStr.split(',')[0]);
                const encoded = decodedStr.split(',')[1];
                const raw = atob(encoded);
                const arr = new Uint8Array(Array.from(raw, c => c.charCodeAt(0)));
                decodedChunks[idx] = Array.from(arr);
                receivedCount.value = Object.keys(decodedChunks).length;
                if (expectedChunks.value) progressPct.value = (receivedCount.value / expectedChunks.value) * 100;

                // when complete
                if (expectedChunks.value && receivedCount.value === expectedChunks.value){
                  assembleFile();
                }
              }
            }catch(e){ log('Decode error: ' + e); }
          }

          function assembleFile(){
            statusMessage.value = 'Assembling file...';
            const out = [];
            for (let i=0;i<expectedChunks.value;i++){
              out.push(...decodedChunks[i]);
            }
            const compressed = new Uint8Array(out);
            let inflated;
            try{
              inflated = pako.inflate(compressed);
            }catch(e){ statusMessage.value = 'Inflation failed: ' + e; log('Inflate error:'+e); return; }

            lastInflatedLength.value = inflated.length;
            const blob = new Blob([inflated]);
            const url = URL.createObjectURL(blob);
            downloadUrl.value = url;
            completed.value = true;
            statusMessage.value = 'File ready';
            log('File assembled: ' + fileName.value + ' (' + formattedBytes(inflated.length) + ')');

            // auto-stop camera to save power
            stopReceiver();
          }

          function formattedBytes(n){ if(!n) return '0 B'; const units=['B','KB','MB','GB']; let i=0; let val=n; while(val>=1024 && i<units.length-1){val/=1024;i++;} return val.toFixed(2)+' '+units[i]; }

          async function scanLoop(){
            const zbar = await zbarWasm();
            while (scanLoopActive){
              try{
                ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
                const symbols = await zbar.scanImageData(imageData);
                if (symbols && symbols.length){
                  const decoded = symbols[0].decode();
                  decodePayload(decoded);
                }
              }catch(e){ log('Scan loop error: ' + e); }
              await new Promise(r=>setTimeout(r, 50));
            }
          }

          onMounted(async ()=>{
            videoElement = document.getElementById('videoElement');
            canvas = document.createElement('canvas');
            ctx = canvas.getContext('2d');
            await listCameras();
          });

          async function switchCamera(){
            if (isReceiving.value) { stopReceiver(); await new Promise(r=>setTimeout(r,200)); startReceiver(); }
          }

          return { isReceiving, startReceiver, stopReceiver, cameras, cameraId, switchCamera, statusMessage, expectedChunks, receivedCount, progressPct, fileName, downloadUrl, completed, debug, formattedBytes, lastInflatedLength };
        }
      }).mount('#app');
    </script>
  </body>
</html>
